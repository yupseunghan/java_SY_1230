<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>배열</title>
	<script>
		/* 
		배열 선언 방법
		var 배열명 = [];
		var 배열명 = [값1, 값2 ,... ];
		var 배열명 = new Array(크기);
		var 배열명 = new Array(값1, 값2, ...);
		var 배열명 = Array(값1, 값2, ...);

		js 배열에서는 값들인 같은 자료형이 아니어도 가능
		*/
		let arr = [1, '1', true, '1', {
			name : "홍길동",
			age : 21
		}];
		document.write(`배열 : ${arr}`, "<hr>");

		/* 
		- 요소 추가/삭제
		push(값)
		  - 값을 배열 끝에 추가
		unshift(값)
		  - 값을 배열 처음에 추가
		pop()
		  - 배열 끝에 있는 값을 제거하고 리턴
		shfit()
		  - 배열 처음에 있는 값을 제거하고 리턴
		*/
		let obj = arr.pop();
		document.write('<h3>pop을 이용하여 제거</h3>');
		document.write(`제거한 값 : ${obj}`, '<br>');
		document.write(`배열 : ${arr}`,'<br>');

		arr.push("안녕하세요");
		document.write('<h3>push을 이용하여 추가</h3>');
		document.write(`배열 : ${arr}`,'<br>');

		let val = arr.shift();
		document.write('<h3>shift을 이용하여 제거</h3>');
		document.write(`제거한 값 : ${val}`, '<br>');
		document.write(`배열 : ${arr}`,'<br>');

		arr.unshift("사과");
		document.write('<h3>unshift을 이용하여 추가</h3>');
		document.write(`배열 : ${arr}`,'<hr>');

		/*
		- 요소 탐색
		indexOf(값)
		  - 값이 배열에 앞에서 부터 몇번지에 있는지 반환. 
			- 없으면 -1
			- 값과 타입이 일치
		lastIndexOf(값)
		  - 값이 배열에 뒤에서 부터 몇번지에 있는지 반환
			- 없으면 -1
			- 값과 타입이 일치
		includes
		  - 값이 배열에 있는지 없는지를 반환
		*/
		var search = '1';
		document.write('<h3>탐색</h3>');
		document.write(
			`배열에 ${search}가 몇번지에 있습니까?(앞에서부터) ${arr.indexOf(search)}`,"<br>");
		document.write(
			`배열에 ${search}가 몇번지에 있습니까?(뒤에서부터) ${arr.lastIndexOf(search)}`, "<br>");
		document.write(
			`배열에 ${search}가 있습니까? ${arr.includes(search)}`, "<hr>");

		/* 
		join(구분자)
		  - 배열 값들 사이에 구분자를 추가하여 하나의 문자열로 반환
		*/
		document.write('<h3>join</h3>');
		document.write(arr.join(","),"<br>");
		document.write(arr.join(", "),"<br>");
		document.write(arr.join(" - "),"<hr>");

		/*
		잘라내기
		slice(start?, end?)
		  - 배열을 잘라내서 부분 배열을 생성해서 반환
			- 원본은 안 바뀜
			- start번지에서 end-1번지까지 부분 배열을 반환
		splice(start, count?)
		  - 배열에서 start번지에서 count개만큼 삭제해서 삭제된 값을 반환
			- 원본은 바뀜
		splice(start, count, ...items?)
		  - 배열에서 start번지에서 count개만큼 삭제한 후 items를 추가
		*/
		document.write('<h3>잘라내기</h3>');
		document.write('<h4>slice</h4>');
		var arr2 = arr.slice();
		var arr3 = arr.slice(2,4);
		document.write(`원본 : ${arr}` , `<br>`);
		document.write(`slice() : ${arr2}` , `<br>`);
		document.write(`slice(2,4) : ${arr3}` , `<br>`);
		
		document.write('<h4>splice</h4>');
		document.write(`원본 : ${arr}` , `<br>`);
		var arr4 = arr.splice(0,1);
		document.write(`splice(0,1) : ${arr4}` , `<br>`);
		document.write(`작업후 원본 : ${arr}` , `<br>`);
		var arr5 = arr.splice(0,2, 3,4,5,6,7,8);
		document.write(`splice(0,2, 3,4,5,6,7,8,) : ${arr5}` , `<br>`);
		document.write(`작업후 원본 : ${arr}` , `<hr>`);

		/* 
		map(콜백함수)
		  - 각 요소에 콜백 함수를 호출해서 만들어진 새로운 배열을 반환
			- 원본은 안 바뀜
		filter(콜백함수)
		  - 콜백함수 결과가 true인 요소들만 필터링
		find(콜백함수)
		  - 콜백함수가 처음으로 true가 되는 요소를 반환
		forEach(콜백함수)
		  - 각 요소에 콜백 함수를 실행
		reduce(콜백함수, 초기값)
		  - 콜백함수를 이용하여 하나의 값을 도출
		
		map, filter, find, forEach의 콜백함수 형태
		(value, index, array) =>{
		
		}
		- value는 배열에서 꺼낸 값
		- index는 배열에서의 위치(번지)
		- array는 배열 전체
		*/
		arr = [1, 2, 3, 4, 5, 6, 7, 8];
		document.write(`원본 : ${arr}` , `<br>`);
		
		document.write('<h4>map</h4>');
		let arr6 = arr.map(v=> v*2);
		document.write(`원본 * 2 : ${arr6}` , `<br>`);
		let arr7 = arr.map(v=>{
			return {
				age : v
			}
		});
		document.write(`원본 => 객체 배열 : ${arr7}` , `<br>`);

		document.write('<h4>filter</h4>');
		let arr8 = arr.filter(v=> v % 2 == 0);
		document.write(`원본 => 짝수 : ${arr8}` , `<br>`);

		document.write('<h4>find</h4>');
		let val2 = arr.find(v=> v % 2 == 0);
		document.write(`첫번째 짝수 : ${val2}` , `<br>`);

		document.write('<h4>forEach</h4>');
		arr.forEach((v, i)=>{
			document.write(`${i}번지 : ${v}`, '<br>');
		});

		document.write('<h4>reduce</h4>');
		arr.push("abc");
		arr.push(NaN);
		arr.push(Infinity);
		//숫자 원소들만 합해서 더하는 작업
		var sum = arr.reduce((acc, v)=>{
			if(typeof v != 'number'){
				return acc;
			}
			if(isNaN(v)){
				return acc;
			}
			if(!isFinite(v)){
				return acc;
			}
			return acc + v;
		}, 0);
		document.write(`배열의 합 : ${sum}`, '<br>');
	</script>
</head>
<body>
	
</body>
</html>